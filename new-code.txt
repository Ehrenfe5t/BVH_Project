BVHAccelerator.h

#ifndef BVH_ACCELERATOR_H
#define BVH_ACCELERATOR_H

#include "ModelImporter.h"
#include "ProgressBarUtils.h"
#include "bvh.pb.h"
#include <vector>
#include <string>

// BVH包围体类型
enum class BVHBoundType {
    AABB,    // 轴对齐包围盒
    SPHERE   // 包围球
};

// BVH节点结构体
struct BVHNode {
    // 基础信息
    int node_id = -1;          // 节点唯一ID
    int depth = 0;             // 节点深度
    bool is_leaf = false;      // 是否叶子节点
    BVHBoundType bound_type;   // 包围体类型
    int left_child = -1;       // 左子节点ID
    int right_child = -1;      // 右子节点ID

    // 三角形索引（仅叶子节点有效）
    std::vector<int> triangle_indices;

    // 包围体（二选一）
    struct AABB {
        Point3D min;           // 最小值
        Point3D max;           // 最大值
        double surface_area = 0.0; // 表面积
    } aabb;

    struct BoundingSphere {
        Point3D center;        // 球心
        double radius = 0.0;   // 半径
    } sphere;
};

// BVH加速器类（SAH优化）
class BVHAccelerator {
public:
    // 静态常量（SAH代价参数）
    static const int LEAF_THRESHOLD;  // 叶子节点三角形阈值
    static const int MAX_DEPTH;       // 最大递归深度
    static const double TRAVERSAL_COST;    // 遍历代价
    static const double INTERSECTION_COST; // 相交测试代价

    // 构造函数
    BVHAccelerator(const ModelImporter& model_importer, BVHBoundType bound_type);

    // 构建BVH（SAH优化）
    void BuildBVH(bool show_progress = true);

    // 导出BVH到Protobuf文件
    bool ExportBVHToProto(const std::string& filepath) const;

    // 从Protobuf文件导入BVH
    bool ImportBVHFromProto(const std::string& filepath);

    // 获取BVH节点列表
    const std::vector<BVHNode>& GetBVHNodes() const { return bvh_nodes_; }

private:
    // 递归构建BVH节点
    int BuildBVHRecursive(const std::vector<int>& triangle_indices, int depth, ProgressBarUtils& progress_bar);

    // 计算三角形质心
    Point3D CalculateTriangleCentroid(int triangle_index) const;

    // 计算AABB包围盒
    BVHNode::AABB CalculateAABB(const std::vector<int>& triangle_indices) const;

    // 计算包围球
    BVHNode::BoundingSphere CalculateBoundingSphere(const std::vector<int>& triangle_indices) const;

    // 合并两个AABB
    BVHNode::AABB MergeAABB(const BVHNode::AABB& a, const BVHNode::AABB& b) const;

    // 合并两个包围球
    BVHNode::BoundingSphere MergeSphere(const BVHNode::BoundingSphere& a, const BVHNode::BoundingSphere& b) const;

    // 成员变量
    const ModelImporter& model_importer_;  // 模型数据引用
    BVHBoundType bound_type_;              // 包围体类型
    std::vector<BVHNode> bvh_nodes_;       // BVH节点列表
};

#endif // BVH_ACCELERATOR_H


ModelImporter.h

#ifndef MODEL_IMPORTER_H
#define MODEL_IMPORTER_H

#include <string>
#include <vector>
#include <cstdint>
#include "ProgressBarUtils.h"
#include "bvh.pb.h"

struct Point3D {
    double x, y, z;
    Point3D() : x(0), y(0), z(0) {}
    Point3D(double x_, double y_, double z_) : x(x_), y(y_), z(z_) {}
};

class ModelImporter {
public:
    bool LoadOBJ(const std::string& filepath, bool show_progress = true);
    std::string GenerateSceneID() const;

    struct OBJMetadata {
        std::string filename;
        uint64_t modify_time_ms;
        uint64_t file_size;
        uint64_t file_hash;
        int vertex_count;
        int triangle_count;
    };
    OBJMetadata GetOBJMetadata() const;

    bool ExportSceneDataToProto(const std::string& filepath) const;

    // 缓存加载接口
    void Clear();
    void AddVertex(const Point3D& vert);
    void AddTriangleNormal(const Point3D& normal);
    void AddTriangleP1(int idx);
    void AddTriangleP2(int idx);
    void AddTriangleP3(int idx);
    void SetMetadata(const BVHProto::SceneDataProto_Metadata& meta);

    // ========== 关键修改：统一返回类型为 size_t，仅声明不内联 ==========
    const std::vector<Point3D>& GetVertices() const { return vertices_; }
    const std::vector<Point3D>& GetTriangleNormals() const { return triangle_normals_; }
    const std::vector<int>& GetTriangleP1() const { return triangle_p1_; }
    const std::vector<int>& GetTriangleP2() const { return triangle_p2_; }
    const std::vector<int>& GetTriangleP3() const { return triangle_p3_; }

    // 仅声明，实现移到cpp中，返回类型改为size_t
    size_t GetVertexCount() const;
    size_t GetTriangleCount() const;

private:
    uint64_t CalculateFileHash(const std::string& filepath) const;
    uint64_t GetFileModifyTimeMs(const std::string& filepath) const;

    std::string obj_filepath_;
    OBJMetadata metadata_;
    std::vector<Point3D> vertices_;
    std::vector<Point3D> triangle_normals_;
    std::vector<int> triangle_p1_;
    std::vector<int> triangle_p2_;
    std::vector<int> triangle_p3_;
};

#endif // MODEL_IMPORTER_H

ProgressBarUtils.h

#ifndef PROGRESS_BAR_UTILS_H
#define PROGRESS_BAR_UTILS_H

#include <string>
#include <atomic>
#include <mutex>

// 控制台实时进度条工具类
// 特点：
// 1. 线程安全（原子变量+互斥锁）
// 2. 无第三方依赖，纯标准库实现
// 3. 支持并行任务的进度累加
class ProgressBarUtils {
public:
    // 初始化进度条
    // 参数：
    //   step_name - 当前进度条对应的任务名称（如"OBJ加载"）
    //   total - 任务总数量（如总三角形数、总节点数）
    //   bar_length - 进度条字符长度（默认50）
    ProgressBarUtils(const std::string& step_name, int total, int bar_length = 50);

    // 更新进度（线程安全）
    // 参数：
    //   increment - 进度增量（默认+1）
    void Update(int increment = 1);

    // 强制刷新进度条显示（手动调用）
    void Refresh();

    // 获取当前进度百分比
    double GetProgressPercent() const;

    // 检查任务是否完成
    bool IsCompleted() const;

    // 重置进度条（可复用）
    void Reset(const std::string& new_step_name, int new_total);

    // 新增：获取当前进度的准确值（避免全局函数通过百分比反推导致精度丢失）
    int GetCurrentValue() const { return current_.load(std::memory_order_relaxed); }

private:
    // 绘制进度条核心函数（私有，内部调用）
    void DrawProgressBar();

    std::string step_name_;          // 当前进度条对应的任务名称
    int bar_length_;                 // 进度条字符长度（默认50）
    std::atomic<int> total_;         // 【修改】任务总数量改为原子变量，避免多线程数据竞争
    std::atomic<int> current_;       // 当前进度（原子变量，支持并行更新）
    mutable std::mutex draw_mutex_;  // 绘制互斥锁（避免多线程刷屏混乱）
};

// 全局便捷函数：快速创建并使用进度条
// 适用于简单的单步任务
void UpdateProgressBar(const std::string& step_name, int current, int total);

#endif // PROGRESS_BAR_UTILS_H

ProtoUtils.h

#ifndef PROTO_UTILS_H
#define PROTO_UTILS_H

#include "bvh.pb.h" // Protobuf编译生成的头文件（需先编译bvh.proto）
#include <string>
#include <fstream>
#include <stdexcept>
#include <google/protobuf/message.h>
// 新增：文件系统头文件
#include <filesystem>

// Protobuf序列化/反序列化工具类
// 功能：封装Protobuf消息与文件的读写操作，替代原有JSON工具类
// 优化：Deserialize系列接口不再抛异常，失败返回空对象（提升容错性）
class ProtoUtils {
public:
    // 序列化Protobuf消息到文件
    // 参数：
    //   message - 待序列化的Protobuf消息对象
    //   filepath - 输出文件路径（建议后缀.proto）
    // 异常：文件写入失败时抛出std::runtime_error
    static void SerializeToFile(const google::protobuf::Message& message, const std::string& filepath);

    // 从文件反序列化到Protobuf消息
    // 参数：
    //   message - 接收数据的Protobuf消息对象（输出参数）
    //   filepath - 输入文件路径
    // 返回：是否成功读取
    // 异常：文件读取失败/解析失败时抛出std::runtime_error
    static bool DeserializeFromFile(google::protobuf::Message& message, const std::string& filepath);

    // ========== 专用序列化接口（简化业务代码调用） ==========
    // 序列化BVH结构数据
    static void SerializeBVHStructure(const BVHProto::BVHStructureProto& bvh_struct, const std::string& filepath);

    // 序列化射线碰撞数据
    static void SerializeRayHitData(const BVHProto::RayHitDataProto& ray_hit_data, const std::string& filepath);

    // 序列化场景数据（用于缓存）
    static void SerializeSceneData(const BVHProto::SceneDataProto& scene_data, const std::string& filepath);

    // ========== 专用反序列化接口（容错版） ==========
    // 说明：失败时返回空对象，不抛异常，由上层判断有效性
    static BVHProto::BVHStructureProto DeserializeBVHStructure(const std::string& filepath);
    static BVHProto::RayHitDataProto DeserializeRayHitData(const std::string& filepath);
    static BVHProto::SceneDataProto DeserializeSceneData(const std::string& filepath);

private:
    // 私有构造函数：禁止实例化工具类
    ProtoUtils() = delete;
    ~ProtoUtils() = delete;

    // 禁用拷贝/移动
    ProtoUtils(const ProtoUtils&) = delete;
    ProtoUtils& operator=(const ProtoUtils&) = delete;
    ProtoUtils(ProtoUtils&&) = delete;
    ProtoUtils& operator=(ProtoUtils&&) = delete;

    // 私有工具函数 - 检查文件是否有效（存在+非空+非目录）
    static bool IsFileValid(const std::string& filepath);
};

#endif // PROTO_UTILS_H

RayIntersection.h

#ifndef RAY_INTERSECTION_H
#define RAY_INTERSECTION_H

#include <string>
#include <vector>
#include <atomic>
#include "ModelImporter.h"
#include "BVHAccelerator.h"
#include "ProgressBarUtils.h"
#include "ProtoUtils.h"

// 射线结构体（与Protobuf的RayProto对应）
struct Ray {
    Point3D origin;        // 射线起点
    Point3D direction;     // 射线方向
    double max_distance;   // 最大检测距离
    bool normalized;       // 方向是否已归一化

    Ray() : max_distance(100.0), normalized(false) {}
    Ray(const Point3D& origin_, const Point3D& direction_, double max_dist_ = 100.0)
        : origin(origin_), direction(direction_), max_distance(max_dist_), normalized(false) {}

    // 归一化射线方向（优化版：先算平方和避免精度损失）
    void Normalize();
};

// 单个碰撞结果（内存中使用）
struct SingleHitResult {
    double distance = 0.0;
    int triangle_index = -1;
    Point3D hit_point;
    bool has_hit = false;
};

// 射线碰撞检测类（修改版）
// 新增：
// 1. 支持Protobuf格式导出碰撞结果（无碰撞时也生成完整文件）
// 2. 集成进度条（碰撞检测过程）
// 3. 支持并行检测的进度累加
// 4. 新增包围体相交检测函数（BVH遍历核心）
class RayIntersection {
public:
    RayIntersection(const ModelImporter& model_importer, const BVHAccelerator& bvh_accelerator);

    // 执行射线碰撞检测（优化版：先过滤后排序）
    // 参数：
    //   ray - 检测射线
    //   show_progress - 是否显示进度条（默认true）
    // 返回：所有碰撞结果（按距离升序排列）
    std::vector<SingleHitResult> Intersect(const Ray& ray, bool show_progress = true);

    // 导出射线+碰撞数据为Protobuf格式（核心修改：无碰撞也生成完整文件）
    // 参数：
    //   ray - 检测射线
    //   hit_results - 碰撞结果列表（可为空）
    //   filepath - 输出文件路径
    //   sample_count - 射线轨迹采样点数（默认100，最小1）
    // 返回：是否导出成功
    bool ExportRayHitDataToProto(const Ray& ray, const std::vector<SingleHitResult>& hit_results,
        const std::string& filepath, int sample_count = 100) const;

    // 获取射线轨迹采样点（用于可视化，处理sample_count为0的边界情况）
    std::vector<Point3D> GetRayTrajectory(const Ray& ray, int sample_count = 100) const;

private:
    // 递归检测BVH节点（内部核心函数，修改版：使用子节点ID+包围体检测）
    void IntersectBVHNode(const Ray& ray, int node_id, std::vector<SingleHitResult>& hit_results,
        std::atomic<int>& processed_tri_count, ProgressBarUtils& progress_bar);

    // 检测射线与单个三角形的碰撞（内部工具函数，Möller-Trumbore算法）
    SingleHitResult IntersectTriangle(const Ray& ray, int triangle_index) const;

    // 新增：射线与AABB包围盒相交检测（Slab算法）
    bool IntersectAABB(const Ray& ray, const BVHNode::AABB& aabb) const;

    // 新增：射线与包围球相交检测（二次方程求解）
    bool IntersectSphere(const Ray& ray, const BVHNode::BoundingSphere& sphere) const;

    // 将内存中的Ray转换为Protobuf的RayProto
    BVHProto::RayProto ConvertToProtoRay(const Ray& ray) const;

    // 将内存中的SingleHitResult转换为Protobuf的SingleHitResult
    BVHProto::SingleHitResult ConvertToProtoHitResult(const SingleHitResult& hit) const;

    const ModelImporter& model_importer_;      // 模型导入器引用
    const BVHAccelerator& bvh_accelerator_;    // BVH加速器引用
};

#endif // RAY_INTERSECTION_H

SceneCacheManager.h

#ifndef SCENE_CACHE_MANAGER_H
#define SCENE_CACHE_MANAGER_H

#include <string>
#include <filesystem>
#include "ModelImporter.h"
#include "BVHAccelerator.h"
#include "ProtoUtils.h"

// 场景缓存管理器
// 功能：
// 1. 管理基于Protobuf的场景数据/BVH结构缓存
// 2. 校验缓存有效性（scene_id+文件属性，容错版：单个BVH失效不删全量）
// 3. 自动创建/读取/删除缓存文件（保存时自动备份，失败恢复）
// 核心逻辑：能用则用，单个文件损坏则删单个，新场景则新建
class SceneCacheManager {
public:
    // 构造函数
    // 参数：cache_root - 缓存根目录（默认./cache）
    SceneCacheManager(const std::string& cache_root = "./cache");

    // 检查场景缓存是否有效（容错版）
    // 规则：
    //   1. 场景数据文件必须有效，否则删除全量缓存
    //   2. BVH文件单个失效仅删除该文件，不删全量
    // 参数：
    //   scene_id - 场景唯一标识
    //   metadata - OBJ文件元数据（用于校验）
    // 返回：是否缓存完全有效
    bool IsCacheValid(const std::string& scene_id, const ModelImporter::OBJMetadata& metadata);

    // 加载场景缓存
    // 参数：
    //   scene_id - 场景唯一标识
    //   model_importer - 接收场景数据的导入器对象
    //   aabb_bvh - 接收AABB-BVH数据的加速器对象
    //   sphere_bvh - 接收Sphere-BVH数据的加速器对象
    // 返回：是否加载成功
    bool LoadCache(const std::string& scene_id, ModelImporter& model_importer,
        BVHAccelerator& aabb_bvh, BVHAccelerator& sphere_bvh);

    // 保存场景缓存（安全版）
    // 规则：
    //   1. 先保存到临时目录，验证有效后替换
    //   2. 替换前备份旧缓存，失败自动恢复
    // 参数：
    //   scene_id - 场景唯一标识
    //   model_importer - 待保存的场景数据
    //   aabb_bvh - 待保存的AABB-BVH数据
    //   sphere_bvh - 待保存的Sphere-BVH数据
    // 返回：是否保存成功
    bool SaveCache(const std::string& scene_id, const ModelImporter& model_importer,
        const BVHAccelerator& aabb_bvh, const BVHAccelerator& sphere_bvh);

    // 删除指定场景的缓存
    // 参数：scene_id - 场景唯一标识
    // 返回：是否删除成功
    bool DeleteCache(const std::string& scene_id) const;

    // 获取场景缓存目录路径（统一替换反斜杠，跨平台兼容）
    std::string GetCacheDir(const std::string& scene_id) const;

    // 获取场景数据缓存文件路径
    std::string GetSceneDataCachePath(const std::string& scene_id) const;

    // 获取AABB-BVH缓存文件路径
    std::string GetAABB_BVHCachedPath(const std::string& scene_id) const;

    // 获取Sphere-BVH缓存文件路径
    std::string GetSphere_BVHCachedPath(const std::string& scene_id) const;

private:
    // 创建缓存目录（递归创建）
    bool CreateCacheDir(const std::string& scene_id) const;

    // 校验单个缓存文件的完整性（严谨的反序列化校验）
    bool ValidateCacheFile(const std::string& filepath) const;

    // 工具函数：检查文件是否存在且非空
    bool IsFileValid(const std::string& filepath) const;

    std::filesystem::path cache_root_; // 缓存根目录路径（跨平台）
};

#endif // SCENE_CACHE_MANAGER_H

BVHAccelerator.cpp

#define _CRT_SECURE_NO_WARNINGS
#define _USE_MATH_DEFINES
#include "BVHAccelerator.h"
#include "ProtoUtils.h"
#include <algorithm>
#include <cmath>
#include <iostream>
#include <numeric>
#include <chrono>
#include <filesystem>
#include <stdexcept>

// 进一步降低Sphere的相交代价，强制分割（核心修复）
const int BVHAccelerator::LEAF_THRESHOLD = 8;
const int BVHAccelerator::MAX_DEPTH = 64;
const double BVHAccelerator::TRAVERSAL_COST = 1.0;
const double BVHAccelerator::INTERSECTION_COST = 3.0; // 从4.0降至3.0，提升分割优先级

// 构造函数（无修改）
BVHAccelerator::BVHAccelerator(const ModelImporter& model_importer, BVHBoundType bound_type)
    : model_importer_(model_importer), bound_type_(bound_type) {}

// 构建BVH主函数（新增日志：输出模型AABB范围）
void BVHAccelerator::BuildBVH(bool show_progress) {
    auto start_time = std::chrono::high_resolution_clock::now();
    bvh_nodes_.clear();

    std::vector<int> triangle_indices(model_importer_.GetTriangleCount());
    std::iota(triangle_indices.begin(), triangle_indices.end(), 0);

    if (triangle_indices.empty()) {
        throw std::runtime_error("BVHAccelerator: 无三角形数据，无法构建BVH");
    }

    // 输出模型整体AABB范围（调试射线是否命中）
    BVHNode::AABB model_aabb = CalculateAABB(triangle_indices);
    std::cout << "BVHAccelerator: 模型AABB范围 - min(" << model_aabb.min.x << "," << model_aabb.min.y << "," << model_aabb.min.z
        << "), max(" << model_aabb.max.x << "," << model_aabb.max.y << "," << model_aabb.max.z << ")" << std::endl;

    std::string progress_name = "BVH构建(";
    progress_name += (bound_type_ == BVHBoundType::AABB ? "AABB" : "Sphere");
    progress_name += ")";
    ProgressBarUtils progress_bar(progress_name, static_cast<int>(triangle_indices.size() * 2), 50);

    int root_node_id = BuildBVHRecursive(triangle_indices, 0, progress_bar);

    auto end_time = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time);

    std::cout << "BVHAccelerator: BVH构建完成 - 节点总数: " << bvh_nodes_.size()
        << ", 耗时: " << duration.count() << "ms" << std::endl;
}

// 递归构建BVH节点（新增日志：输出分割信息）
int BVHAccelerator::BuildBVHRecursive(const std::vector<int>& triangle_indices, int depth, ProgressBarUtils& progress_bar) {
    if (depth >= MAX_DEPTH || triangle_indices.size() <= LEAF_THRESHOLD) {
        BVHNode leaf_node;
        leaf_node.node_id = static_cast<int>(bvh_nodes_.size());
        leaf_node.depth = depth;
        leaf_node.is_leaf = true;
        leaf_node.triangle_indices = triangle_indices;
        leaf_node.left_child = -1;
        leaf_node.right_child = -1;

        if (bound_type_ == BVHBoundType::AABB) {
            leaf_node.aabb = CalculateAABB(triangle_indices);
            leaf_node.bound_type = BVHBoundType::AABB;
        }
        else {
            leaf_node.sphere = CalculateBoundingSphere(triangle_indices);
            leaf_node.bound_type = BVHBoundType::SPHERE;
            // 输出叶子节点包围球范围
            std::cout << "BVHAccelerator: 叶子节点[" << leaf_node.node_id << "] 包围球 - 中心("
                << leaf_node.sphere.center.x << "," << leaf_node.sphere.center.y << "," << leaf_node.sphere.center.z
                << "), 半径: " << leaf_node.sphere.radius << std::endl;
        }

        bvh_nodes_.push_back(leaf_node);
        progress_bar.Update(static_cast<int>(triangle_indices.size()));
        return leaf_node.node_id;
    }

    BVHNode parent_node;
    parent_node.node_id = static_cast<int>(bvh_nodes_.size());
    parent_node.depth = depth;
    parent_node.is_leaf = false;
    parent_node.left_child = -1;
    parent_node.right_child = -1;

    double parent_surface_area = 0.0;
    if (bound_type_ == BVHBoundType::AABB) {
        parent_node.aabb = CalculateAABB(triangle_indices);
        parent_node.bound_type = BVHBoundType::AABB;
        parent_surface_area = parent_node.aabb.surface_area;
    }
    else {
        parent_node.sphere = CalculateBoundingSphere(triangle_indices);
        parent_node.bound_type = BVHBoundType::SPHERE;
        parent_surface_area = 4 * M_PI * pow(parent_node.sphere.radius, 2);
        // 输出非叶子节点包围球范围
        std::cout << "BVHAccelerator: 非叶子节点[" << parent_node.node_id << "] 包围球 - 中心("
            << parent_node.sphere.center.x << "," << parent_node.sphere.center.y << "," << parent_node.sphere.center.z
            << "), 半径: " << parent_node.sphere.radius << std::endl;
    }

    int best_axis = -1;
    double best_split_pos = 0.0;
    double best_cost = static_cast<double>(triangle_indices.size()) * INTERSECTION_COST;
    std::vector<int> left_indices, right_indices;

    for (int axis = 0; axis < 3; ++axis) {
        std::vector<std::pair<double, int>> centroids;
        for (int tri_idx : triangle_indices) {
            Point3D centroid = CalculateTriangleCentroid(tri_idx);
            centroids.emplace_back((axis == 0) ? centroid.x : (axis == 1) ? centroid.y : centroid.z, tri_idx);
        }
        std::sort(centroids.begin(), centroids.end());

        int n = static_cast<int>(centroids.size());
        std::vector<double> prefix_cost(n, 0.0);
        std::vector<double> suffix_cost(n, 0.0);

        if (bound_type_ == BVHBoundType::AABB) {
            std::vector<BVHNode::AABB> prefix_aabbs(n);
            std::vector<BVHNode::AABB> suffix_aabbs(n);
            prefix_aabbs[0] = CalculateAABB({ centroids[0].second });
            prefix_cost[0] = prefix_aabbs[0].surface_area * 1;
            for (int i = 1; i < n; ++i) {
                prefix_aabbs[i] = MergeAABB(prefix_aabbs[i - 1], CalculateAABB({ centroids[i].second }));
                prefix_cost[i] = prefix_aabbs[i].surface_area * (i + 1);
            }
            suffix_aabbs.back() = CalculateAABB({ centroids.back().second });
            suffix_cost.back() = suffix_aabbs.back().surface_area * 1;
            for (int i = n - 2; i >= 0; --i) {
                suffix_aabbs[i] = MergeAABB(suffix_aabbs[i + 1], CalculateAABB({ centroids[i].second }));
                suffix_cost[i] = suffix_aabbs[i].surface_area * (n - i);
            }
        }
        else {
            std::vector<BVHNode::BoundingSphere> prefix_spheres(n);
            std::vector<BVHNode::BoundingSphere> suffix_spheres(n);
            prefix_spheres[0] = CalculateBoundingSphere({ centroids[0].second });
            prefix_cost[0] = 4 * M_PI * pow(prefix_spheres[0].radius, 2) * 1;
            for (int i = 1; i < n; ++i) {
                prefix_spheres[i] = MergeSphere(prefix_spheres[i - 1], CalculateBoundingSphere({ centroids[i].second }));
                prefix_cost[i] = 4 * M_PI * pow(prefix_spheres[i].radius, 2) * (i + 1);
            }
            suffix_spheres.back() = CalculateBoundingSphere({ centroids.back().second });
            suffix_cost.back() = 4 * M_PI * pow(suffix_spheres.back().radius, 2) * 1;
            for (int i = n - 2; i >= 0; --i) {
                suffix_spheres[i] = MergeSphere(suffix_spheres[i + 1], CalculateBoundingSphere({ centroids[i].second }));
                suffix_cost[i] = 4 * M_PI * pow(suffix_spheres[i].radius, 2) * (n - i);
            }
        }

        for (int i = 1; i < n; ++i) {
            double split_pos = (centroids[i - 1].first + centroids[i].first) / 2.0;
            double cost = TRAVERSAL_COST + INTERSECTION_COST * (prefix_cost[i - 1] + suffix_cost[i]) / parent_surface_area;
            if (cost < best_cost - 1e-3) {
                best_cost = cost;
                best_axis = axis;
                best_split_pos = split_pos;
                left_indices.clear();
                right_indices.clear();
                for (const auto& centroid : centroids) {
                    if (centroid.first < split_pos) {
                        left_indices.push_back(centroid.second);
                    }
                    else {
                        right_indices.push_back(centroid.second);
                    }
                }
            }
        }
    }

    // 输出分割信息（调试）
    if (best_axis != -1) {
        std::cout << "BVHAccelerator: 节点[" << parent_node.node_id << "] 分割 - 轴: " << best_axis
            << ", 位置: " << best_split_pos << ", 左子节点三角形数: " << left_indices.size()
            << ", 右子节点三角形数: " << right_indices.size() << std::endl;
    }
    else {
        std::cout << "BVHAccelerator: 节点[" << parent_node.node_id << "] 不分割 - 分割代价(" << best_cost
            << ") >= 不分割代价(" << static_cast<double>(triangle_indices.size()) * INTERSECTION_COST << ")" << std::endl;
    }

    if (best_axis == -1 || best_cost >= static_cast<double>(triangle_indices.size()) * INTERSECTION_COST - 1e-3) {
        BVHNode leaf_node;
        leaf_node.node_id = static_cast<int>(bvh_nodes_.size());
        leaf_node.depth = depth;
        leaf_node.is_leaf = true;
        leaf_node.triangle_indices = triangle_indices;
        leaf_node.left_child = -1;
        leaf_node.right_child = -1;
        if (bound_type_ == BVHBoundType::AABB) {
            leaf_node.aabb = CalculateAABB(triangle_indices);
        }
        else {
            leaf_node.sphere = CalculateBoundingSphere(triangle_indices);
        }
        bvh_nodes_.push_back(leaf_node);
        progress_bar.Update(static_cast<int>(triangle_indices.size()));
        return leaf_node.node_id;
    }

    if (left_indices.empty() || right_indices.empty()) {
        BVHNode leaf_node;
        leaf_node.node_id = static_cast<int>(bvh_nodes_.size());
        leaf_node.depth = depth;
        leaf_node.is_leaf = true;
        leaf_node.triangle_indices = triangle_indices;
        leaf_node.left_child = -1;
        leaf_node.right_child = -1;
        if (bound_type_ == BVHBoundType::AABB) {
            leaf_node.aabb = CalculateAABB(triangle_indices);
        }
        else {
            leaf_node.sphere = CalculateBoundingSphere(triangle_indices);
        }
        bvh_nodes_.push_back(leaf_node);
        progress_bar.Update(static_cast<int>(triangle_indices.size()));
        return leaf_node.node_id;
    }

    int left_node_id = BuildBVHRecursive(left_indices, depth + 1, progress_bar);
    int right_node_id = BuildBVHRecursive(right_indices, depth + 1, progress_bar);

    parent_node.left_child = left_node_id;
    parent_node.right_child = right_node_id;
    bvh_nodes_.push_back(parent_node);
    return parent_node.node_id;
}

// 计算三角形质心（无修改）
Point3D BVHAccelerator::CalculateTriangleCentroid(int triangle_index) const {
    const auto& v0 = model_importer_.GetVertices()[model_importer_.GetTriangleP1()[triangle_index]];
    const auto& v1 = model_importer_.GetVertices()[model_importer_.GetTriangleP2()[triangle_index]];
    const auto& v2 = model_importer_.GetVertices()[model_importer_.GetTriangleP3()[triangle_index]];
    return { (v0.x + v1.x + v2.x) / 3.0, (v0.y + v1.y + v2.y) / 3.0, (v0.z + v1.z + v2.z) / 3.0 };
}

// 计算AABB包围盒（无修改）
BVHNode::AABB BVHAccelerator::CalculateAABB(const std::vector<int>& triangle_indices) const {
    BVHNode::AABB aabb;
    aabb.min = { INFINITY, INFINITY, INFINITY };
    aabb.max = { -INFINITY, -INFINITY, -INFINITY };
    for (int tri_idx : triangle_indices) {
        const auto& v0 = model_importer_.GetVertices()[model_importer_.GetTriangleP1()[tri_idx]];
        const auto& v1 = model_importer_.GetVertices()[model_importer_.GetTriangleP2()[tri_idx]];
        const auto& v2 = model_importer_.GetVertices()[model_importer_.GetTriangleP3()[tri_idx]];
        aabb.min.x = std::min({ aabb.min.x, v0.x, v1.x, v2.x });
        aabb.min.y = std::min({ aabb.min.y, v0.y, v1.y, v2.y });
        aabb.min.z = std::min({ aabb.min.z, v0.z, v1.z, v2.z });
        aabb.max.x = std::max({ aabb.max.x, v0.x, v1.x, v2.x });
        aabb.max.y = std::max({ aabb.max.y, v0.y, v1.y, v2.y });
        aabb.max.z = std::max({ aabb.max.z, v0.z, v1.z, v2.z });
    }
    double dx = aabb.max.x - aabb.min.x;
    double dy = aabb.max.y - aabb.min.y;
    double dz = aabb.max.z - aabb.min.z;
    aabb.surface_area = 2 * (dx * dy + dx * dz + dy * dz);
    return aabb;
}

// 计算包围球（优化精度+日志）
BVHNode::BoundingSphere BVHAccelerator::CalculateBoundingSphere(const std::vector<int>& triangle_indices) const {
    BVHNode::BoundingSphere sphere;
    sphere.center = { 0.0, 0.0, 0.0 };
    sphere.radius = 0.0;
    if (triangle_indices.empty()) return sphere;

    // 第一步：计算所有顶点的中心点（优化精度）
    Point3D centroid = { 0.0, 0.0, 0.0 };
    int vertex_count = 0;
    for (int tri_idx : triangle_indices) {
        const auto& v0 = model_importer_.GetVertices()[model_importer_.GetTriangleP1()[tri_idx]];
        const auto& v1 = model_importer_.GetVertices()[model_importer_.GetTriangleP2()[tri_idx]];
        const auto& v2 = model_importer_.GetVertices()[model_importer_.GetTriangleP3()[tri_idx]];
        centroid.x += v0.x + v1.x + v2.x;
        centroid.y += v0.y + v1.y + v2.y;
        centroid.z += v0.z + v1.z + v2.z;
        vertex_count += 3;
    }
    centroid.x /= vertex_count;
    centroid.y /= vertex_count;
    centroid.z /= vertex_count;

    // 第二步：计算最大距离（优化精度，用double存储）
    double max_dist_sq = 0.0;
    for (int tri_idx : triangle_indices) {
        const auto& v0 = model_importer_.GetVertices()[model_importer_.GetTriangleP1()[tri_idx]];
        const auto& v1 = model_importer_.GetVertices()[model_importer_.GetTriangleP2()[tri_idx]];
        const auto& v2 = model_importer_.GetVertices()[model_importer_.GetTriangleP3()[tri_idx]];
        auto calc_dist_sq = [&centroid](const Point3D& p) {
            double dx = p.x - centroid.x;
            double dy = p.y - centroid.y;
            double dz = p.z - centroid.z;
            return dx * dx + dy * dy + dz * dz;
            };
        max_dist_sq = std::max({ max_dist_sq, calc_dist_sq(v0), calc_dist_sq(v1), calc_dist_sq(v2) });
    }

    sphere.center = centroid;
    sphere.radius = sqrt(max_dist_sq) + 1e-6; // 加容错，避免半径过小
    std::cout << "BVHAccelerator: 包围球计算完成 - 中心(" << sphere.center.x << "," << sphere.center.y << "," << sphere.center.z
        << "), 半径: " << sphere.radius << ", 三角形数: " << triangle_indices.size() << std::endl;
    return sphere;
}

// 合并AABB（无修改）
BVHNode::AABB BVHAccelerator::MergeAABB(const BVHNode::AABB& a, const BVHNode::AABB& b) const {
    BVHNode::AABB merged;
    merged.min.x = std::min(a.min.x, b.min.x);
    merged.min.y = std::min(a.min.y, b.min.y);
    merged.min.z = std::min(a.min.z, b.min.z);
    merged.max.x = std::max(a.max.x, b.max.x);
    merged.max.y = std::max(a.max.y, b.max.y);
    merged.max.z = std::max(a.max.z, b.max.z);
    double dx = merged.max.x - merged.min.x;
    double dy = merged.max.y - merged.min.y;
    double dz = merged.max.z - merged.min.z;
    merged.surface_area = 2 * (dx * dy + dx * dz + dy * dz);
    return merged;
}

// 合并包围球（优化精度+日志）
BVHNode::BoundingSphere BVHAccelerator::MergeSphere(const BVHNode::BoundingSphere& a, const BVHNode::BoundingSphere& b) const {
    BVHNode::BoundingSphere merged;
    double dx = b.center.x - a.center.x;
    double dy = b.center.y - a.center.y;
    double dz = b.center.z - a.center.z;
    double dist = sqrt(dx * dx + dy * dy + dz * dz);

    // 优化浮点容错
    if (dist + std::min(a.radius, b.radius) <= std::max(a.radius, b.radius) + 1e-6) {
        merged = (a.radius > b.radius) ? a : b;
        std::cout << "BVHAccelerator: 包围球合并（包含关系）- 新半径: " << merged.radius << std::endl;
        return merged;
    }

    // 避免除0
    double new_radius = (a.radius + b.radius + dist) / 2.0;
    double ratio = dist < 1e-6 ? 0.5 : (new_radius - a.radius) / dist;
    merged.center.x = a.center.x + dx * ratio;
    merged.center.y = a.center.y + dy * ratio;
    merged.center.z = a.center.z + dz * ratio;
    merged.radius = new_radius;

    std::cout << "BVHAccelerator: 包围球合并（分离关系）- 原半径(" << a.radius << "," << b.radius
        << "), 距离: " << dist << ", 新半径: " << new_radius << std::endl;
    return merged;
}

// 导出/导入BVH（无修改，保留之前修复）
bool BVHAccelerator::ExportBVHToProto(const std::string& filepath) const { /* 原有代码不变 */ }
bool BVHAccelerator::ImportBVHFromProto(const std::string& filepath) { /* 原有代码不变 */ }

main.cpp

#include <iostream>
#include <string>
#include <stdexcept>
#include <filesystem>  // 确保包含文件系统头文件
#include "ModelImporter.h"
#include "BVHAccelerator.h"
#include "RayIntersection.h"
#include "SceneCacheManager.h"
#include "ProgressBarUtils.h"
#include "ProtoUtils.h"

// 配置参数
const std::string OUTPUT_DIR = "./output"; // 输出目录
const std::string CACHE_DIR = "./cache";   // 缓存目录

// 射线参数（可根据需求调整）
const Point3D RAY_ORIGIN = Point3D(4.0, -10.0, 0.5);       // 射线起点
const Point3D RAY_DIRECTION = Point3D(0.0, -1.0, 0.0);    // 射线方向
const double RAY_MAX_DISTANCE = 1200.0;                   // 射线最大距离

// 创建输出目录
void CreateOutputDir() {
    if (!std::filesystem::exists(OUTPUT_DIR)) {
        std::filesystem::create_directories(OUTPUT_DIR);
        std::cout << "Main: 创建输出目录 - " << OUTPUT_DIR << std::endl;
    }
}

int main() {
    try {
        // ========== 关键修改：替换命令行参数为硬编码绝对路径 ==========
        // 1. 直接定义OBJ文件的绝对路径（替换为你实际的文件路径）
        // 注意：Windows路径用双反斜杠\\，或正斜杠/，或R原始字符串R"(路径)"
        std::string obj_filepath = R"(G:\BVH_Project\BVH\obj\f2.obj)";
        // 示例备选写法（二选一）：
        // std::string obj_filepath = "G:/BVH_Project/BVH/models/your_scene.obj";
        // std::string obj_filepath = "G:\\BVH_Project\\BVH\\models\\your_scene.obj";

        // 2. 保留文件存在性检查（确保路径正确）
        if (!std::filesystem::exists(obj_filepath)) {
            std::cerr << "Main: OBJ文件不存在 - " << obj_filepath << std::endl;
            return 1;
        }
        // ========== 结束修改 ==========

        // 2. 初始化核心组件
        CreateOutputDir();
        ModelImporter model_importer;
        SceneCacheManager cache_manager(CACHE_DIR);

        // 3. 加载OBJ模型
        std::cout << "\n===== 步骤1：加载OBJ模型 =====" << std::endl;
        if (!model_importer.LoadOBJ(obj_filepath, true)) {
            std::cerr << "Main: OBJ模型加载失败" << std::endl;
            return 1;
        }
        std::string scene_id = model_importer.GenerateSceneID();
        auto obj_metadata = model_importer.GetOBJMetadata();

        // 4. 初始化BVH加速器
        BVHAccelerator aabb_bvh(model_importer, BVHBoundType::AABB);
        BVHAccelerator sphere_bvh(model_importer, BVHBoundType::SPHERE);

        // 5. 校验并加载缓存（若有效）
        std::cout << "\n===== 步骤2：检查BVH缓存 =====" << std::endl;
        bool cache_valid = cache_manager.IsCacheValid(scene_id, obj_metadata);
        if (cache_valid) {
            if (!cache_manager.LoadCache(scene_id, model_importer, aabb_bvh, sphere_bvh)) {
                std::cerr << "Main: 缓存加载失败，将重新构建BVH" << std::endl;
                cache_valid = false;
            }
        }

        // 6. 构建BVH（缓存无效时）
        if (!cache_valid) {
            std::cout << "\n===== 步骤3：构建AABB-BVH =====" << std::endl;
            aabb_bvh.BuildBVH(true);

            std::cout << "\n===== 步骤4：构建Sphere-BVH =====" << std::endl;
            sphere_bvh.BuildBVH(true);

            // 保存缓存
            std::cout << "\n===== 步骤5：保存BVH缓存 =====" << std::endl;
            cache_manager.SaveCache(scene_id, model_importer, aabb_bvh, sphere_bvh);
        }

        // 7. 导出BVH结构（Protobuf格式）
        std::cout << "\n===== 步骤6：导出BVH结构 =====" << std::endl;
        aabb_bvh.ExportBVHToProto(OUTPUT_DIR + "/aabb_bvh_structure.proto");
        sphere_bvh.ExportBVHToProto(OUTPUT_DIR + "/sphere_bvh_structure.proto");

        // 8. 射线碰撞检测
        std::cout << "\n===== 步骤7：执行射线碰撞检测 =====" << std::endl;
        Ray ray(RAY_ORIGIN, RAY_DIRECTION, RAY_MAX_DISTANCE);
        RayIntersection ray_intersection(model_importer, aabb_bvh); // 使用AABB-BVH检测
        auto hit_results = ray_intersection.Intersect(ray, true);

        // 9. 导出射线碰撞数据（Protobuf格式）
        std::cout << "\n===== 步骤8：导出碰撞检测结果 =====" << std::endl;
        ray_intersection.ExportRayHitDataToProto(
            ray, hit_results,
            OUTPUT_DIR + "/ray_hit_data.proto",
            100 // 轨迹采样点数
        );

        // 10. 输出检测结果汇总
        std::cout << "\n===== 检测完成 =====" << std::endl;
        std::cout << "射线起点: (" << ray.origin.x << ", " << ray.origin.y << ", " << ray.origin.z << ")" << std::endl;
        std::cout << "射线方向: (" << ray.direction.x << ", " << ray.direction.y << ", " << ray.direction.z << ")" << std::endl;
        std::cout << "最大检测距离: " << ray.max_distance << std::endl;
        std::cout << "碰撞点数量: " << hit_results.size() << std::endl;
        if (!hit_results.empty()) {
            std::cout << "最近碰撞点: 距离=" << hit_results[0].distance
                << ", 三角形索引=" << hit_results[0].triangle_index
                << ", 坐标=(" << hit_results[0].hit_point.x << ", "
                << hit_results[0].hit_point.y << ", " << hit_results[0].hit_point.z << ")" << std::endl;
        }

        std::cout << "\n所有数据已导出至: " << OUTPUT_DIR << std::endl;
        return 0;

    }
    catch (const std::exception& e) {
        std::cerr << "\nMain: 程序执行异常 - " << e.what() << std::endl;
        return 1;
    }
    catch (...) {
        std::cerr << "\nMain: 未知异常" << std::endl;
        return 1;
    }
}

ModelImporter.cpp

#include "bvh.pb.h"
#include "ProtoUtils.h"
#include "ModelImporter.h"
#include <fstream>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <cstdint>
#include <filesystem>
#include <chrono>
#include <cstring>
#include <cmath> // 确保包含sqrt所需的头文件

// CRC32查表（用于文件哈希计算）
static const uint32_t crc32_table[] = {
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

// 计算32位CRC值
static uint32_t crc32(const uint8_t* data, size_t length) {
    uint32_t crc = 0xFFFFFFFF;
    for (size_t i = 0; i < length; ++i) {
        crc = crc32_table[(crc ^ data[i]) & 0xFF] ^ (crc >> 8);
    }
    return crc ^ 0xFFFFFFFF;
}

// 加载OBJ文件
bool ModelImporter::LoadOBJ(const std::string& filepath, bool show_progress) {
    // 清空原有数据
    Clear(); // 替换原有的逐个clear，复用新增的Clear接口
    obj_filepath_ = filepath;

    // 打开OBJ文件
    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "ModelImporter: 无法打开OBJ文件 - " << filepath << std::endl;
        return false;
    }

    // 第一步：预估三角形总数（用于进度条）
    int total_estimated_tris = 0;
    std::string temp_line;
    while (std::getline(file, temp_line)) {
        if (temp_line.substr(0, 2) == "f ") {
            total_estimated_tris++;
        }
    }
    file.clear(); // 重置文件指针状态
    file.seekg(0); // 回到文件开头

    // 初始化进度条
    ProgressBarUtils progress_bar("OBJ模型加载", total_estimated_tris);
    int current_tri_count = 0;

    // 第二步：解析OBJ文件内容
    std::string line;
    while (std::getline(file, line)) {
        // 跳过空行和注释
        if (line.empty() || line[0] == '#') continue;

        // 新增：跳过光滑组标记行（s 0/s 1）
        std::istringstream temp_stream(line);
        std::string first_token;
        temp_stream >> first_token;
        if (first_token == "s") continue;

        std::istringstream line_stream(line);
        std::string token;
        line_stream >> token;

        // 解析顶点
        if (token == "v") {
            double x, y, z;
            line_stream >> x >> y >> z;
            vertices_.emplace_back(x, y, z);
        }
        // 解析三角形面（仅支持f v1 v2 v3格式）
        else if (token == "f") {
            int v1, v2, v3;
            // 检查是否能正确读取3个顶点索引
            if (!(line_stream >> v1 >> v2 >> v3)) {
                std::cerr << "ModelImporter: 无效的面格式 - 行内容: " << line << std::endl;
                continue;
            }

            // ========== 关键修改1：添加索引有效性检查 ==========
            // 1. 检查索引是否为正数（OBJ索引是1-based）
            if (v1 <= 0 || v2 <= 0 || v3 <= 0) {
                std::cerr << "ModelImporter: 无效的顶点索引（非正数） - 行内容: " << line << std::endl;
                continue;
            }
            // 2. 检查转换为0-based后是否超出顶点列表范围
            int idx1 = v1 - 1;
            int idx2 = v2 - 1;
            int idx3 = v3 - 1;
            if (idx1 >= vertices_.size() || idx2 >= vertices_.size() || idx3 >= vertices_.size()) {
                std::cerr << "ModelImporter: 顶点索引越界 - 索引(" << v1 << "," << v2 << "," << v3
                    << "), 顶点总数: " << vertices_.size() << std::endl;
                continue;
            }
            // ========== 结束关键修改1 ==========

            // 存储0-based索引（仅当索引有效时）
            triangle_p1_.push_back(idx1);
            triangle_p2_.push_back(idx2);
            triangle_p3_.push_back(idx3);

            // ========== 关键修改2：使用检查后的索引访问顶点 ==========
            const Point3D& p1 = vertices_[idx1];
            const Point3D& p2 = vertices_[idx2];
            const Point3D& p3 = vertices_[idx3];
            // ========== 结束关键修改2 ==========

            // 计算三角形法向量（简单叉乘）
            Point3D v = { p2.x - p1.x, p2.y - p1.y, p2.z - p1.z };
            Point3D w = { p3.x - p1.x, p3.y - p1.y, p3.z - p1.z };

            Point3D normal;
            normal.x = v.y * w.z - v.z * w.y;
            normal.y = v.z * w.x - v.x * w.z;
            normal.z = v.x * w.y - v.y * w.x;

            // 归一化法向量
            double len = sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
            if (len > 1e-6) {
                normal.x /= len;
                normal.y /= len;
                normal.z /= len;
            }
            triangle_normals_.push_back(normal);

            // 更新进度条
            current_tri_count++;
            if (show_progress) {
                progress_bar.Update(1);
            }
        }
    }

    file.close();

    // 第三步：更新元数据
    metadata_.filename = filepath;
    metadata_.modify_time_ms = GetFileModifyTimeMs(filepath); // 保留但scene_id不再使用
    metadata_.file_size = std::filesystem::file_size(filepath);
    metadata_.file_hash = CalculateFileHash(filepath); // 修改为完整文件哈希
    metadata_.vertex_count = GetVertexCount();
    metadata_.triangle_count = GetTriangleCount();

    std::cout << "ModelImporter: OBJ加载完成 - 顶点数: " << GetVertexCount()
        << ", 三角形数: " << GetTriangleCount() << std::endl;

    return true;
}

// 【核心修改】生成稳定的场景唯一标识（去掉毫秒级修改时间，用户保证文件不修改）
std::string ModelImporter::GenerateSceneID() const {
    // 规则：文件名_文件大小_完整文件CRC32哈希（去掉毫秒级时间，保证稳定）
    std::filesystem::path path(obj_filepath_);
    std::string filename = path.filename().string();

    // 替换文件名中的特殊字符（避免路径问题）
    std::replace(filename.begin(), filename.end(), ' ', '_');
    std::replace(filename.begin(), filename.end(), '.', '_');

    return filename + "_" + std::to_string(metadata_.file_size) +
        "_" + std::to_string(metadata_.file_hash);
}

// 获取OBJ文件元数据
ModelImporter::OBJMetadata ModelImporter::GetOBJMetadata() const {
    return metadata_;
}

// 导出场景数据为Protobuf格式
bool ModelImporter::ExportSceneDataToProto(const std::string& filepath) const {
    try {
        // 构建SceneDataProto对象
        BVHProto::SceneDataProto scene_data;

        // 填充元数据
        auto* meta = scene_data.mutable_metadata();
        meta->set_scene_id(GenerateSceneID());
        meta->set_obj_filename(obj_filepath_);
        meta->set_file_modify_time(metadata_.modify_time_ms);
        meta->set_file_size(metadata_.file_size);
        meta->set_file_hash(metadata_.file_hash);
        meta->set_vertex_count(metadata_.vertex_count);
        meta->set_triangle_count(metadata_.triangle_count);

        // 填充顶点数据
        for (const auto& vert : vertices_) {
            auto* p = scene_data.add_vertices();
            p->set_x(vert.x);
            p->set_y(vert.y);
            p->set_z(vert.z);
        }

        // 填充三角形法向量
        for (const auto& normal : triangle_normals_) {
            auto* p = scene_data.add_triangle_normals();
            p->set_x(normal.x);
            p->set_y(normal.y);
            p->set_z(normal.z);
        }

        // 填充三角形顶点索引
        for (int idx : triangle_p1_) scene_data.add_triangle_p1(idx);
        for (int idx : triangle_p2_) scene_data.add_triangle_p2(idx);
        for (int idx : triangle_p3_) scene_data.add_triangle_p3(idx);

        // 序列化到文件
        ProtoUtils::SerializeSceneData(scene_data, filepath);
        std::cout << "ModelImporter: 场景数据已导出为Protobuf - " << filepath << std::endl;
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "ModelImporter: 导出场景数据失败 - " << e.what() << std::endl;
        return false;
    }
}

// 【核心修改】计算整个文件的CRC32哈希（而非前1024字节），保证哈希唯一稳定
uint64_t ModelImporter::CalculateFileHash(const std::string& filepath) const {
    std::ifstream file(filepath, std::ios::binary);
    if (!file.is_open()) {
        std::cerr << "ModelImporter: 无法打开文件计算哈希 - " << filepath << std::endl;
        return 0;
    }

    // 读取整个文件内容
    file.seekg(0, std::ios::end);
    size_t file_size = file.tellg();
    file.seekg(0, std::ios::beg);

    uint8_t* buffer = new uint8_t[file_size];
    file.read(reinterpret_cast<char*>(buffer), file_size);
    size_t bytes_read = file.gcount();
    file.close();

    // 计算CRC32哈希
    uint32_t crc_hash = crc32(buffer, bytes_read);
    delete[] buffer;

    // 转换为uint64_t返回（保持类型兼容）
    return static_cast<uint64_t>(crc_hash);
}

// 获取文件修改时间（毫秒级，跨平台）- 保留但scene_id不再使用
uint64_t ModelImporter::GetFileModifyTimeMs(const std::string& filepath) const {
    try {
        auto ftime = std::filesystem::last_write_time(filepath);
        // 转换为时间戳（毫秒）
        auto sctp = std::chrono::time_point_cast<std::chrono::milliseconds>(
            ftime - std::filesystem::file_time_type::clock::now().time_since_epoch() +
            std::chrono::system_clock::now().time_since_epoch()
        );
        return sctp.time_since_epoch().count();
    }
    catch (...) {
        return 0;
    }
}

// ========== 实现新增的缓存加载接口 ==========
// 清空所有数据
void ModelImporter::Clear() {
    obj_filepath_.clear();
    // 清空元数据
    metadata_ = OBJMetadata();
    // 清空容器
    vertices_.clear();
    triangle_normals_.clear();
    triangle_p1_.clear();
    triangle_p2_.clear();
    triangle_p3_.clear();
}

// 添加单个顶点
void ModelImporter::AddVertex(const Point3D& vert) {
    vertices_.push_back(vert);
}

// 添加单个三角形法线
void ModelImporter::AddTriangleNormal(const Point3D& normal) {
    triangle_normals_.push_back(normal);
}

// 添加三角形索引P1
void ModelImporter::AddTriangleP1(int idx) {
    triangle_p1_.push_back(idx);
}

// 添加三角形索引P2
void ModelImporter::AddTriangleP2(int idx) {
    triangle_p2_.push_back(idx);
}

// 添加三角形索引P3
void ModelImporter::AddTriangleP3(int idx) {
    triangle_p3_.push_back(idx);
}

// 设置元数据（从Protobuf的SceneMetadataProto填充）
void ModelImporter::SetMetadata(const BVHProto::SceneDataProto_Metadata& meta) {
    metadata_.filename = meta.obj_filename();
    metadata_.modify_time_ms = meta.file_modify_time();
    metadata_.file_size = meta.file_size();
    metadata_.file_hash = meta.file_hash();
    metadata_.vertex_count = meta.vertex_count();
    metadata_.triangle_count = meta.triangle_count();
    // 同步更新obj_filepath_
    obj_filepath_ = meta.obj_filename();
}

// 辅助函数：获取顶点数量
size_t ModelImporter::GetVertexCount() const {
    return vertices_.size();
}

// 辅助函数：获取三角形数量
size_t ModelImporter::GetTriangleCount() const {
    return triangle_p1_.size();
}


ProgressBarUtils.cpp

#include "ProgressBarUtils.h"
#include <iostream>
#include <iomanip>
#include <chrono>
#include <thread>
#include <atomic>
#include <mutex>
#include <stdexcept>

// 补充头文件中应该声明的成员（确保编译通过）
// ProgressBarUtils.h 中应包含：
/*
#include <string>
#include <atomic>
#include <mutex>

class ProgressBarUtils {
public:
    ProgressBarUtils(const std::string& step_name, int total, int bar_length = 50);
    void Update(int increment);
    void Refresh();
    double GetProgressPercent() const;
    bool IsCompleted() const;
    void Reset(const std::string& new_step_name, int new_total);
    // 新增：获取当前准确进度值（避免全局函数反推）
    int GetCurrentValue() const { return current_.load(std::memory_order_relaxed); }

private:
    void DrawProgressBar();
    std::string step_name_;
    int bar_length_;
    std::atomic<int> total_;  // 改为原子变量，避免数据竞争
    std::atomic<int> current_;
    mutable std::mutex draw_mutex_;
};

void UpdateProgressBar(const std::string& step_name, int current, int total);
*/

// 进度条构造函数
ProgressBarUtils::ProgressBarUtils(const std::string& step_name, int total, int bar_length)
    : step_name_(step_name), bar_length_(bar_length), total_(total), current_(0) {
    // 校验参数合法性
    if (total <= 0) {
        throw std::invalid_argument("ProgressBarUtils: 任务总数量必须大于0");
    }
    if (bar_length <= 0) {
        throw std::invalid_argument("ProgressBarUtils: 进度条长度必须大于0");
    }
    // 初始化时绘制空进度条
    DrawProgressBar();
}

// 更新进度（线程安全）
void ProgressBarUtils::Update(int increment) {
    if (increment <= 0) {
        return; // 增量无效，直接返回
    }

    // 原子累加进度（支持多线程并行更新）
    int old_val = current_.load(std::memory_order_relaxed);
    int new_val = old_val + increment;
    // 防止进度超过总数量
    if (new_val > total_.load(std::memory_order_relaxed)) {
        new_val = total_.load(std::memory_order_relaxed);
    }
    current_.store(new_val, std::memory_order_relaxed);

    // 刷新进度条显示
    Refresh();
}

// 强制刷新进度条
void ProgressBarUtils::Refresh() {
    std::lock_guard<std::mutex> lock(draw_mutex_); // 加锁防止多线程刷屏混乱
    DrawProgressBar();
}

// 获取当前进度百分比
double ProgressBarUtils::GetProgressPercent() const {
    int total = total_.load(std::memory_order_relaxed);
    if (total <= 0) return 0.0;
    int current = current_.load(std::memory_order_relaxed);
    return static_cast<double>(current) / total * 100.0;
}

// 检查任务是否完成
bool ProgressBarUtils::IsCompleted() const {
    int current = current_.load(std::memory_order_relaxed);
    int total = total_.load(std::memory_order_relaxed);
    return current >= total;
}

// 重置进度条（可复用，线程安全）
void ProgressBarUtils::Reset(const std::string& new_step_name, int new_total) {
    if (new_total <= 0) {
        throw std::invalid_argument("ProgressBarUtils: 重置的任务总数量必须大于0");
    }
    std::lock_guard<std::mutex> lock(draw_mutex_);
    step_name_ = new_step_name;
    total_.store(new_total, std::memory_order_relaxed);
    current_.store(0, std::memory_order_relaxed);
    DrawProgressBar();
}

// 绘制进度条核心函数（私有）
void ProgressBarUtils::DrawProgressBar() {
    // 显式load原子变量，避免数据竞争
    int current = current_.load(std::memory_order_relaxed);
    int total = total_.load(std::memory_order_relaxed);
    double progress = static_cast<double>(current) / total;
    int filled_length = static_cast<int>(bar_length_ * progress);

    // 构建进度条字符（=表示已完成，空格表示未完成）
    std::string bar;
    bar.append(filled_length, '=');
    bar.append(bar_length_ - filled_length, ' ');

    // 格式化输出（\r覆盖当前行，不刷屏）
    std::cout << "\r" << step_name_ << ": [" << bar << "] "
        << std::fixed << std::setprecision(1) << progress * 100 << "% "
        << "(" << current << "/" << total << ")"
        << std::flush;

    // 任务完成时换行，避免后续输出覆盖进度条
    if (current >= total) {
        std::cout << std::endl;
    }
}

// 全局便捷函数：修复逻辑错误，避免精度丢失
void UpdateProgressBar(const std::string& step_name, int current, int total) {
    // 使用局部静态智能指针，避免内存泄漏
    static std::unique_ptr<ProgressBarUtils> temp_bar = nullptr;
    static std::string last_step_name;
    static int last_total = 0;

    // 校验total合法性，提前返回避免抛异常
    if (total <= 0) {
        std::cerr << "UpdateProgressBar: 任务总数量必须大于0，跳过进度条更新" << std::endl;
        return;
    }

    // 首次调用/任务名称/总数量变化时，创建新进度条
    if (!temp_bar || step_name != last_step_name || total != last_total) {
        temp_bar = std::make_unique<ProgressBarUtils>(step_name, total);
        last_step_name = step_name;
        last_total = total;
    }

    // 直接获取当前进度值，计算增量（修复精度丢失问题）
    int current_val = std::min(current, total); // 防止current超过total
    int last_val = temp_bar->GetCurrentValue();
    int increment = current_val - last_val;

    if (increment > 0) {
        temp_bar->Update(increment);
    }

    // 任务完成时重置，避免下次复用错误
    if (current_val >= total) {
        temp_bar.reset();
        last_step_name = "";
        last_total = 0;
    }
}

ProtoUtils.cpp

#define _CRT_SECURE_NO_WARNINGS
#include "ProtoUtils.h"
#include <iostream>
#include <fstream>
#include <filesystem>
#include <stdexcept>

// 序列化BVH结构（修复二进制模式+flush）
bool ProtoUtils::SerializeBVHStructure(const BVHProto::BVHStructureProto& data, const std::string& filepath) {
    try {
        // 确保输出目录存在
        std::filesystem::path dir = std::filesystem::path(filepath).parent_path();
        if (!std::filesystem::exists(dir)) {
            std::filesystem::create_directories(dir);
        }

        // 二进制模式打开+强制flush
        std::ofstream ofs(filepath, std::ios::binary | std::ios::trunc);
        if (!ofs.is_open()) {
            throw std::runtime_error("无法打开文件：" + filepath);
        }

        bool serialize_ok = data.SerializeToOstream(&ofs);
        ofs.flush();
        ofs.close();

        if (!serialize_ok) {
            throw std::runtime_error("BVH结构序列化失败");
        }

        // 检查文件大小
        uintmax_t file_size = std::filesystem::file_size(filepath);
        std::cout << "ProtoUtils: 序列化成功 - " << filepath << " (大小: " << file_size << " bytes)" << std::endl;
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "ProtoUtils: 序列化失败 - " << e.what() << " - " << filepath << std::endl;
        return false;
    }
}

// 反序列化BVH结构
bool ProtoUtils::DeserializeBVHStructure(BVHProto::BVHStructureProto& data, const std::string& filepath) {
    try {
        if (!std::filesystem::exists(filepath)) {
            std::cerr << "ProtoUtils: 文件不存在 - " << filepath << std::endl;
            return false;
        }

        std::ifstream ifs(filepath, std::ios::binary);
        if (!ifs.is_open()) {
            throw std::runtime_error("无法打开文件：" + filepath);
        }

        bool deserialize_ok = data.ParseFromIstream(&ifs);
        ifs.close();

        if (!deserialize_ok) {
            throw std::runtime_error("BVH结构反序列化失败");
        }

        std::cout << "ProtoUtils: 反序列化成功 - " << filepath << std::endl;
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "ProtoUtils: Protobuf消息反序列化失败 - " << filepath << std::endl;
        std::cerr << "ProtoUtils: 反序列化BVH结构失败 - " << filepath << std::endl;
        return false;
    }
}

// 序列化射线碰撞数据
bool ProtoUtils::SerializeRayHitData(const BVHProto::RayHitDataProto& data, const std::string& filepath) {
    try {
        std::filesystem::path dir = std::filesystem::path(filepath).parent_path();
        if (!std::filesystem::exists(dir)) {
            std::filesystem::create_directories(dir);
        }

        std::ofstream ofs(filepath, std::ios::binary | std::ios::trunc);
        if (!ofs.is_open()) {
            throw std::runtime_error("无法打开文件：" + filepath);
        }

        bool serialize_ok = data.SerializeToOstream(&ofs);
        ofs.flush();
        ofs.close();

        if (!serialize_ok) {
            throw std::runtime_error("射线碰撞数据序列化失败");
        }

        uintmax_t file_size = std::filesystem::file_size(filepath);
        std::cout << "ProtoUtils: 序列化成功 - " << filepath << " (大小: " << file_size << " bytes)" << std::endl;
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "ProtoUtils: 序列化失败 - " << e.what() << " - " << filepath << std::endl;
        return false;
    }
}

// 反序列化射线碰撞数据
bool ProtoUtils::DeserializeRayHitData(BVHProto::RayHitDataProto& data, const std::string& filepath) {
    try {
        if (!std::filesystem::exists(filepath)) {
            std::cerr << "ProtoUtils: 文件不存在 - " << filepath << std::endl;
            return false;
        }

        std::ifstream ifs(filepath, std::ios::binary);
        if (!ifs.is_open()) {
            throw std::runtime_error("无法打开文件：" + filepath);
        }

        bool deserialize_ok = data.ParseFromIstream(&ifs);
        ifs.close();

        if (!deserialize_ok) {
            throw std::runtime_error("射线碰撞数据反序列化失败");
        }

        std::cout << "ProtoUtils: 反序列化成功 - " << filepath << std::endl;
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "ProtoUtils: Protobuf消息反序列化失败 - " << filepath << std::endl;
        std::cerr << "ProtoUtils: 反序列化射线碰撞数据失败 - " << filepath << std::endl;
        return false;
    }
}

// 序列化场景数据
bool ProtoUtils::SerializeSceneData(const BVHProto::SceneDataProto& data, const std::string& filepath) {
    try {
        std::filesystem::path dir = std::filesystem::path(filepath).parent_path();
        if (!std::filesystem::exists(dir)) {
            std::filesystem::create_directories(dir);
        }

        std::ofstream ofs(filepath, std::ios::binary | std::ios::trunc);
        if (!ofs.is_open()) {
            throw std::runtime_error("无法打开文件：" + filepath);
        }

        bool serialize_ok = data.SerializeToOstream(&ofs);
        ofs.flush();
        ofs.close();

        if (!serialize_ok) {
            throw std::runtime_error("场景数据序列化失败");
        }

        uintmax_t file_size = std::filesystem::file_size(filepath);
        std::cout << "ProtoUtils: 序列化成功 - " << filepath << " (大小: " << file_size << " bytes)" << std::endl;
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "ProtoUtils: 序列化失败 - " << e.what() << " - " << filepath << std::endl;
        return false;
    }
}

// 反序列化场景数据
bool ProtoUtils::DeserializeSceneData(BVHProto::SceneDataProto& data, const std::string& filepath) {
    try {
        if (!std::filesystem::exists(filepath)) {
            std::cerr << "ProtoUtils: 文件不存在 - " << filepath << std::endl;
            return false;
        }

        std::ifstream ifs(filepath, std::ios::binary);
        if (!ifs.is_open()) {
            throw std::runtime_error("无法打开文件：" + filepath);
        }

        bool deserialize_ok = data.ParseFromIstream(&ifs);
        ifs.close();

        if (!deserialize_ok) {
            throw std::runtime_error("场景数据反序列化失败");
        }

        std::cout << "ProtoUtils: 反序列化成功 - " << filepath << std::endl;
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "ProtoUtils: Protobuf消息反序列化失败 - " << filepath << std::endl;
        std::cerr << "ProtoUtils: 反序列化场景数据失败 - " << filepath << std::endl;
        return false;
    }
}

RayInterection.cpp
#define _CRT_SECURE_NO_WARNINGS
#include "RayIntersection.h"
#include <cmath>
#include <algorithm>
#include <iostream>
#include <thread>
#include <atomic>
#include <chrono>
#include <ctime>
#include <filesystem>
#include <limits>
#include <stdexcept>

// 射线归一化（新增日志）
void Ray::Normalize() {
    if (normalized) return;
    double len_sq = direction.x * direction.x + direction.y * direction.y + direction.z * direction.z;
    if (len_sq < 1e-18) {
        std::cerr << "Ray: 射线方向向量长度为0，无法归一化" << std::endl;
        return;
    }
    double len = sqrt(len_sq);
    direction.x /= len;
    direction.y /= len;
    direction.z /= len;
    normalized = true;
    std::cout << "Ray: 归一化完成 - 方向(" << direction.x << "," << direction.y << "," << direction.z << ")" << std::endl;
}

// 构造函数（无修改）
RayIntersection::RayIntersection(const ModelImporter& model_importer, const BVHAccelerator& bvh_accelerator)
    : model_importer_(model_importer), bvh_accelerator_(bvh_accelerator) {}

// 射线与AABB相交检测（无修改）
bool RayIntersection::IntersectAABB(const Ray& ray, const BVHNode::AABB& aabb) const { /* 原有代码不变 */ }

// 射线与包围球相交检测（优化精度）
bool RayIntersection::IntersectSphere(const Ray& ray, const BVHNode::BoundingSphere& sphere) const {
    const double EPS = 1e-6; // 调整精度
    Point3D oc = {
        ray.origin.x - sphere.center.x,
        ray.origin.y - sphere.center.y,
        ray.origin.z - sphere.center.z
    };

    double a = ray.direction.x * ray.direction.x + ray.direction.y * ray.direction.y + ray.direction.z * ray.direction.z;
    double b = 2.0 * (oc.x * ray.direction.x + oc.y * ray.direction.y + oc.z * ray.direction.z);
    double c = oc.x * oc.x + oc.y * oc.y + oc.z * oc.z - sphere.radius * sphere.radius;

    double discriminant = b * b - 4 * a * c;
    if (discriminant < 0) return false;

    double sqrt_d = sqrt(discriminant);
    double t = (-b - sqrt_d) / (2.0 * a);

    // 输出相交信息（调试）
    if (t >= EPS && t <= ray.max_distance) {
        std::cout << "RayIntersection: 射线与包围球相交 - t: " << t << ", 球心("
            << sphere.center.x << "," << sphere.center.y << "," << sphere.center.z
            << "), 半径: " << sphere.radius << std::endl;
        return true;
    }
    return false;
}

// 执行射线碰撞检测（核心修复：输出射线与模型范围，调试命中）
std::vector<SingleHitResult> RayIntersection::Intersect(const Ray& ray, bool show_progress) {
    std::vector<SingleHitResult> hit_results;
    Ray ray_normalized = ray;
    ray_normalized.Normalize();

    // 输出射线参数（关键调试）
    std::cout << "RayIntersection: 射线参数 - 起点(" << ray_normalized.origin.x << "," << ray_normalized.origin.y << "," << ray_normalized.origin.z
        << "), 方向(" << ray_normalized.direction.x << "," << ray_normalized.direction.y << "," << ray_normalized.direction.z
        << "), 最大距离: " << ray_normalized.max_distance << std::endl;

    // 输出模型AABB范围（判断射线是否可能命中）
    std::vector<int> all_triangles(model_importer_.GetTriangleCount());
    std::iota(all_triangles.begin(), all_triangles.end(), 0);
    BVHNode::AABB model_aabb;
    model_aabb.min = { INFINITY, INFINITY, INFINITY };
    model_aabb.max = { -INFINITY, -INFINITY, -INFINITY };
    for (int tri_idx : all_triangles) {
        const auto& v0 = model_importer_.GetVertices()[model_importer_.GetTriangleP1()[tri_idx]];
        const auto& v1 = model_importer_.GetVertices()[model_importer_.GetTriangleP2()[tri_idx]];
        const auto& v2 = model_importer_.GetVertices()[model_importer_.GetTriangleP3()[tri_idx]];
        model_aabb.min.x = std::min({ model_aabb.min.x, v0.x, v1.x, v2.x });
        model_aabb.min.y = std::min({ model_aabb.min.y, v0.y, v1.y, v2.y });
        model_aabb.min.z = std::min({ model_aabb.min.z, v0.z, v1.z, v2.z });
        model_aabb.max.x = std::max({ model_aabb.max.x, v0.x, v1.x, v2.x });
        model_aabb.max.y = std::max({ model_aabb.max.y, v0.y, v1.y, v2.y });
        model_aabb.max.z = std::max({ model_aabb.max.z, v0.z, v1.z, v2.z });
    }
    std::cout << "RayIntersection: 模型AABB范围 - min(" << model_aabb.min.x << "," << model_aabb.min.y << "," << model_aabb.min.z
        << "), max(" << model_aabb.max.x << "," << model_aabb.max.y << "," << model_aabb.max.z << ")" << std::endl;

    // 快速判断射线是否与模型AABB相交（提前过滤）
    if (!IntersectAABB(ray_normalized, model_aabb)) {
        std::cerr << "RayIntersection: 射线与模型AABB无相交，直接返回空结果" << std::endl;
        return hit_results;
    }

    int total_tri_count = model_importer_.GetTriangleCount();
    if (total_tri_count <= 0) {
        std::cerr << "RayIntersection: 无三角形数据，跳过碰撞检测" << std::endl;
        return hit_results;
    }

    std::atomic<int> processed_tri_count(0);
    ProgressBarUtils progress_bar("射线碰撞检测", total_tri_count, 50);
    IntersectBVHNode(ray_normalized, 0, hit_results, processed_tri_count, progress_bar);

    // 过滤无效结果并排序
    hit_results.erase(
        std::remove_if(hit_results.begin(), hit_results.end(),
            [&ray_normalized](const SingleHitResult& hit) {
                return hit.distance > ray_normalized.max_distance;
            }
        ),
        hit_results.end()
    );

    std::sort(hit_results.begin(), hit_results.end(),
        [](const SingleHitResult& a, const SingleHitResult& b) {
            return a.distance < b.distance;
        }
    );

    // 输出碰撞结果统计
    std::cout << "RayIntersection: 碰撞检测完成 - 共检测到 " << hit_results.size() << " 个有效碰撞点" << std::endl;
    for (size_t i = 0; i < hit_results.size(); ++i) {
        const auto& hit = hit_results[i];
        std::cout << "  碰撞点[" << i << "] - 距离: " << hit.distance << ", 三角形索引: " << hit.triangle_index
            << ", 坐标(" << hit.hit_point.x << "," << hit.hit_point.y << "," << hit.hit_point.z << ")" << std::endl;
    }

    return hit_results;
}

// 递归检测BVH节点（新增日志：输出遍历信息）
void RayIntersection::IntersectBVHNode(const Ray& ray, int node_id, std::vector<SingleHitResult>& hit_results,
    std::atomic<int>& processed_tri_count, ProgressBarUtils& progress_bar) {
    const auto& bvh_nodes = bvh_accelerator_.GetBVHNodes();
    if (node_id < 0 || node_id >= bvh_nodes.size()) {
        return;
    }

    const auto& node = bvh_nodes[node_id];
    std::cout << "RayIntersection: 遍历节点[" << node.node_id << "] - 深度: " << node.depth
        << ", 叶子节点: " << (node.is_leaf ? "是" : "否") << ", 三角形数: " << node.triangle_indices.size() << std::endl;

    if (node.is_leaf) {
        SingleHitResult closest_hit;
        closest_hit.has_hit = false;
        closest_hit.distance = std::numeric_limits<double>::max();
        for (int tri_idx : node.triangle_indices) {
            SingleHitResult hit = IntersectTriangle(ray, tri_idx);
            if (hit.has_hit && hit.distance <= ray.max_distance && hit.distance < closest_hit.distance) {
                closest_hit = hit;
                std::cout << "RayIntersection: 检测到碰撞 - 三角形索引: " << tri_idx
                    << ", 距离: " << hit.distance << ", 坐标(" << hit.hit_point.x << "," << hit.hit_point.y << "," << hit.hit_point.z << ")" << std::endl;
            }
            processed_tri_count++;
            progress_bar.Update(1);
        }
        if (closest_hit.has_hit) {
            hit_results.push_back(closest_hit);
        }
        return;
    }

    bool intersect_bound = false;
    if (node.bound_type == BVHBoundType::AABB) {
        intersect_bound = IntersectAABB(ray, node.aabb);
    }
    else {
        intersect_bound = IntersectSphere(ray, node.sphere);
    }

    if (intersect_bound) {
        std::cout << "RayIntersection: 节点[" << node.node_id << "] 包围体相交，遍历子节点(" << node.left_child << "," << node.right_child << ")" << std::endl;
        IntersectBVHNode(ray, node.left_child, hit_results, processed_tri_count, progress_bar);
        IntersectBVHNode(ray, node.right_child, hit_results, processed_tri_count, progress_bar);
    }
    else {
        std::cout << "RayIntersection: 节点[" << node.node_id << "] 包围体不相交，跳过子节点" << std::endl;
    }
}

// 射线与三角形相交检测（优化精度：EPSILON=1e-6）
SingleHitResult RayIntersection::IntersectTriangle(const Ray& ray, int triangle_index) const {
    SingleHitResult hit;
    hit.triangle_index = triangle_index;
    hit.has_hit = false;

    const auto& tri_p1 = model_importer_.GetTriangleP1();
    const auto& tri_p2 = model_importer_.GetTriangleP2();
    const auto& tri_p3 = model_importer_.GetTriangleP3();
    const auto& vertices = model_importer_.GetVertices();

    int v0_idx = tri_p1[triangle_index];
    int v1_idx = tri_p2[triangle_index];
    int v2_idx = tri_p3[triangle_index];

    const Point3D& v0 = vertices[v0_idx];
    const Point3D& v1 = vertices[v1_idx];
    const Point3D& v2 = vertices[v2_idx];

    const double EPSILON = 1e-6; // 优化精度，避免过滤有效碰撞
    Point3D e1, e2, h, s, q;
    double a, f, u, v, t;

    e1.x = v1.x - v0.x;
    e1.y = v1.y - v0.y;
    e1.z = v1.z - v0.z;

    e2.x = v2.x - v0.x;
    e2.y = v2.y - v0.y;
    e2.z = v2.z - v0.z;

    // 叉乘：h = ray.direction × e2
    h.x = ray.direction.y * e2.z - ray.direction.z * e2.y;
    h.y = ray.direction.z * e2.x - ray.direction.x * e2.z;
    h.z = ray.direction.x * e2.y - ray.direction.y * e2.x;

    a = e1.x * h.x + e1.y * h.y + e1.z * h.z;

    // 射线与三角形平行（优化容错）
    if (a > -EPSILON && a < EPSILON) {
        return hit;
    }

    f = 1.0 / a;
    s.x = ray.origin.x - v0.x;
    s.y = ray.origin.y - v0.y;
    s.z = ray.origin.z - v0.z;

    u = f * (s.x * h.x + s.y * h.y + s.z * h.z);
    if (u < -EPSILON || u > 1.0 + EPSILON) { // 扩大容错范围
        return hit;
    }

    // 叉乘：q = s × e1
    q.x = s.y * e1.z - s.z * e1.y;
    q.y = s.z * e1.x - s.x * e1.z;
    q.z = s.x * e1.y - s.y * e1.x;

    v = f * (ray.direction.x * q.x + ray.direction.y * q.y + ray.direction.z * q.z);
    if (v < -EPSILON || u + v > 1.0 + EPSILON) { // 扩大容错范围
        return hit;
    }

    t = f * (e2.x * q.x + e2.y * q.y + e2.z * q.z);
    if (t < EPSILON || t > ray.max_distance) {
        return hit;
    }

    // 有效碰撞
    hit.has_hit = true;
    hit.distance = t;
    hit.hit_point.x = ray.origin.x + ray.direction.x * t;
    hit.hit_point.y = ray.origin.y + ray.direction.y * t;
    hit.hit_point.z = ray.origin.z + ray.direction.z * t;

    return hit;
}

// 导出射线碰撞数据（新增日志：确保射线参数写入）
bool RayIntersection::ExportRayHitDataToProto(const Ray& ray, const std::vector<SingleHitResult>& hit_results,
    const std::string& filepath, int sample_count) const {
    try {
        int valid_sample_count = std::max(sample_count, 1);
        Ray ray_normalized = ray;
        ray_normalized.Normalize();

        BVHProto::RayHitDataProto ray_hit_data;

        // 填充元数据
        auto* meta = ray_hit_data.mutable_metadata();
        auto now = std::chrono::system_clock::now();
        auto time_t_now = std::chrono::system_clock::to_time_t(now);
        struct tm time_info;
        localtime_s(&time_info, &time_t_now);
        char time_str[20];
        std::strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", &time_info);
        meta->set_export_time(time_str);
        meta->set_ray_max_distance(ray.max_distance);
        meta->set_has_collision(!hit_results.empty());
        meta->set_collision_count(static_cast<int>(hit_results.size()));

        // 强制填充射线参数（核心）
        auto* ray_proto = ray_hit_data.mutable_ray();
        ray_proto->mutable_origin()->set_x(ray.origin.x);
        ray_proto->mutable_origin()->set_y(ray.origin.y);
        ray_proto->mutable_origin()->set_z(ray.origin.z);
        ray_proto->mutable_direction()->set_x(ray.direction.x);
        ray_proto->mutable_direction()->set_y(ray.direction.y);
        ray_proto->mutable_direction()->set_z(ray.direction.z);
        ray_proto->set_max_distance(ray.max_distance);
        ray_proto->set_normalized(ray.normalized);
        std::cout << "RayIntersection: 导出射线参数 - 起点(" << ray.origin.x << "," << ray.origin.y << "," << ray.origin.z
            << "), 方向(" << ray.direction.x << "," << ray.direction.y << "," << ray.direction.z << ")" << std::endl;

        // 填充轨迹采样点
        std::vector<Point3D> trajectory = GetRayTrajectory(ray_normalized, valid_sample_count);
        for (int i = 0; i < trajectory.size(); ++i) {
            double t = static_cast<double>(i) / (valid_sample_count - 1) * ray.max_distance;
            auto* point = ray_hit_data.add_trajectory();
            point->set_index(i);
            point->set_t(t);
            point->mutable_coord()->set_x(trajectory[i].x);
            point->mutable_coord()->set_y(trajectory[i].y);
            point->mutable_coord()->set_z(trajectory[i].z);
        }
        std::cout << "RayIntersection: 导出轨迹采样点 " << trajectory.size() << " 个" << std::endl;

        // 填充碰撞结果
        for (const auto& hit : hit_results) {
            auto* hit_proto = ray_hit_data.add_collisions();
            hit_proto->set_distance(hit.distance);
            hit_proto->set_triangle_index(hit.triangle_index);
            hit_proto->set_has_hit(hit.has_hit);
            hit_proto->mutable_hit_point()->set_x(hit.hit_point.x);
            hit_proto->mutable_hit_point()->set_y(hit.hit_point.y);
            hit_proto->mutable_hit_point()->set_z(hit.hit_point.z);
        }

        // 序列化（二进制模式+强制flush）
        std::ofstream ofs(filepath, std::ios::binary | std::ios::trunc);
        if (!ofs.is_open()) {
            throw std::runtime_error("无法打开文件：" + filepath);
        }
        bool serialize_ok = ray_hit_data.SerializeToOstream(&ofs);
        ofs.flush();
        ofs.close();

        if (!serialize_ok) {
            throw std::runtime_error("Protobuf序列化失败");
        }

        // 检查文件有效性
        std::filesystem::path path(filepath);
        if (!std::filesystem::exists(path)) {
            throw std::runtime_error("文件未生成");
        }
        uintmax_t file_size = std::filesystem::file_size(path);
        std::cout << "RayIntersection: 射线碰撞数据已导出 - " << filepath
            << " | 文件大小: " << file_size << " bytes" << std::endl;

        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "RayIntersection: 导出射线碰撞数据失败 - " << e.what() << std::endl;
        return false;
    }
}

// 其他函数（GetRayTrajectory、ConvertToProtoRay、ConvertToProtoHitResult）无修改

SceneCacheManager.cpp

#include "SceneCacheManager.h"
#include <iostream>
#include <fstream>
#include <stdexcept>
#include <limits>

// 构造函数（无修改）
SceneCacheManager::SceneCacheManager(const std::string& cache_root)
    : cache_root_(cache_root) {
    if (!std::filesystem::exists(cache_root_)) {
        std::filesystem::create_directories(cache_root_);
        std::cout << "SceneCacheManager: 创建缓存根目录 - " << cache_root_ << std::endl;
    }
}

// 新增：工具函数 - 检查文件是否存在且非空（抽离重复逻辑）
bool SceneCacheManager::IsFileValid(const std::string& filepath) const {
    try {
        if (!std::filesystem::exists(filepath) || std::filesystem::is_directory(filepath)) {
            std::cerr << "SceneCacheManager: 文件不存在或为目录 - " << filepath << std::endl;
            return false;
        }
        std::uintmax_t file_size = std::filesystem::file_size(filepath);
        if (file_size <= 0) {
            std::cerr << "SceneCacheManager: 文件为空或大小异常 - " << filepath << " (大小: " << file_size << ")" << std::endl;
            return false;
        }
        return true;
    }
    catch (const std::filesystem::filesystem_error& e) {
        std::cerr << "SceneCacheManager: 检查文件失败 - " << filepath << " | 错误: " << e.what() << std::endl;
        return false;
    }
}

// 【修改1】缓存校验逻辑容错：单个BVH文件失效不删除全部缓存
bool SceneCacheManager::IsCacheValid(const std::string& scene_id, const ModelImporter::OBJMetadata& metadata) {
    std::string cache_dir = GetCacheDir(scene_id);
    if (!std::filesystem::exists(cache_dir)) {
        std::cout << "SceneCacheManager: 缓存目录不存在，缓存无效 - " << scene_id << std::endl;
        return false;
    }

    std::string scene_data_path = GetSceneDataCachePath(scene_id);
    std::string aabb_bvh_path = GetAABB_BVHCachedPath(scene_id);
    std::string sphere_bvh_path = GetSphere_BVHCachedPath(scene_id);

    // 第一步：校验场景数据（核心，必须有效）
    if (!IsFileValid(scene_data_path)) {
        std::cerr << "SceneCacheManager: 场景数据文件无效，删除损坏缓存 - " << scene_id << std::endl;
        DeleteCache(scene_id);
        return false;
    }

    // 第二步：校验BVH文件（单个失效仅标记，不删全部缓存）
    bool aabb_valid = IsFileValid(aabb_bvh_path) && ValidateCacheFile(aabb_bvh_path);
    bool sphere_valid = IsFileValid(sphere_bvh_path) && ValidateCacheFile(sphere_bvh_path);
    if (!aabb_valid || !sphere_valid) {
        std::cerr << "SceneCacheManager: 部分BVH缓存失效（AABB:" << aabb_valid << " | Sphere:" << sphere_valid << "）- " << scene_id << std::endl;
        // 仅删除失效的BVH文件，保留场景数据
        if (!aabb_valid) std::filesystem::remove(aabb_bvh_path);
        if (!sphere_valid) std::filesystem::remove(sphere_bvh_path);
        return false; // 缓存不完全有效，需重建失效的BVH，但不删全部
    }

    // 第三步：校验元数据（恢复modify_time校验，用户保证文件不修改）
    try {
        std::cout << "SceneCacheManager: 开始校验缓存元数据 - " << scene_id << std::endl;
        BVHProto::SceneDataProto cached_scene_data = ProtoUtils::DeserializeSceneData(scene_data_path);
        const auto& cached_meta = cached_scene_data.metadata();

        std::cout << "===== 元数据对比 =====" << std::endl;
        std::cout << "缓存文件大小: " << cached_meta.file_size() << " | 实际: " << metadata.file_size << std::endl;
        std::cout << "缓存文件哈希: " << cached_meta.file_hash() << " | 实际: " << metadata.file_hash << std::endl;
        std::cout << "缓存顶点数: " << cached_meta.vertex_count() << " | 实际: " << metadata.vertex_count << std::endl;
        std::cout << "缓存三角形数: " << cached_meta.triangle_count() << " | 实际: " << metadata.triangle_count << std::endl;

        bool meta_match =
            (cached_meta.file_size() == metadata.file_size) &&
            (cached_meta.file_hash() == metadata.file_hash) &&
            (cached_meta.vertex_count() == metadata.vertex_count) &&
            (cached_meta.triangle_count() == metadata.triangle_count);

        if (!meta_match) {
            std::cout << "SceneCacheManager: 缓存元数据不匹配，删除旧缓存 - " << scene_id << std::endl;
            DeleteCache(scene_id);
            return false;
        }

        std::cout << "SceneCacheManager: 场景缓存有效 - " << scene_id << std::endl;
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "SceneCacheManager: 校验缓存失败 - " << e.what() << " | 删除损坏缓存" << std::endl;
        DeleteCache(scene_id);
        return false;
    }
}

// 加载场景缓存（无核心修改，仅保留原有逻辑）
bool SceneCacheManager::LoadCache(const std::string& scene_id, ModelImporter& model_importer,
    BVHAccelerator& aabb_bvh, BVHAccelerator& sphere_bvh) {
    try {
        std::cout << "SceneCacheManager: 开始加载缓存 - " << scene_id << std::endl;

        std::string scene_data_path = GetSceneDataCachePath(scene_id);
        if (!IsFileValid(scene_data_path)) {
            std::cerr << "SceneCacheManager: 场景数据文件无效，加载失败" << std::endl;
            return false;
        }

        BVHProto::SceneDataProto scene_data = ProtoUtils::DeserializeSceneData(scene_data_path);

        model_importer.Clear();
        std::cout << "SceneCacheManager: 加载顶点数 - " << scene_data.vertices_size() << std::endl;
        for (const auto& p : scene_data.vertices()) {
            model_importer.AddVertex(Point3D(p.x(), p.y(), p.z()));
        }
        std::cout << "SceneCacheManager: 加载法线索引数 - " << scene_data.triangle_normals_size() << std::endl;
        for (const auto& n : scene_data.triangle_normals()) {
            model_importer.AddTriangleNormal(Point3D(n.x(), n.y(), n.z()));
        }
        std::cout << "SceneCacheManager: 加载三角形P1索引数 - " << scene_data.triangle_p1_size() << std::endl;
        for (int idx : scene_data.triangle_p1()) model_importer.AddTriangleP1(idx);
        for (int idx : scene_data.triangle_p2()) model_importer.AddTriangleP2(idx);
        for (int idx : scene_data.triangle_p3()) model_importer.AddTriangleP3(idx);

        model_importer.SetMetadata(scene_data.metadata());

        std::string aabb_bvh_path = GetAABB_BVHCachedPath(scene_id);
        if (!aabb_bvh.ImportBVHFromProto(aabb_bvh_path)) {
            std::cerr << "SceneCacheManager: 加载AABB-BVH缓存失败，仅删除该BVH文件 - " << scene_id << std::endl;
            std::filesystem::remove(aabb_bvh_path); // 仅删失效BVH，不删全部缓存
            return false;
        }

        std::string sphere_bvh_path = GetSphere_BVHCachedPath(scene_id);
        if (!sphere_bvh.ImportBVHFromProto(sphere_bvh_path)) {
            std::cerr << "SceneCacheManager: 加载Sphere-BVH缓存失败，仅删除该BVH文件 - " << scene_id << std::endl;
            std::filesystem::remove(sphere_bvh_path); // 仅删失效BVH，不删全部缓存
            return false;
        }

        std::cout << "SceneCacheManager: 缓存加载完成 - " << scene_id << std::endl;
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "SceneCacheManager: 加载缓存异常 - " << e.what() << " | 删除缓存" << std::endl;
        DeleteCache(scene_id);
        return false;
    }
}

// 【修改2】保存逻辑安全化：先备份旧缓存，失败则恢复
bool SceneCacheManager::SaveCache(const std::string& scene_id, const ModelImporter& model_importer,
    const BVHAccelerator& aabb_bvh, const BVHAccelerator& sphere_bvh) {
    std::string temp_cache_dir = GetCacheDir(scene_id) + "_temp";
    std::string backup_cache_dir = GetCacheDir(scene_id) + "_backup";
    std::filesystem::create_directories(temp_cache_dir);

    try {
        bool all_success = true;
        // 1. 保存到临时目录
        std::string temp_scene_path = temp_cache_dir + "/scene_data.proto";
        if (!model_importer.ExportSceneDataToProto(temp_scene_path) || !IsFileValid(temp_scene_path)) {
            all_success = false;
        }
        std::string temp_aabb_path = temp_cache_dir + "/aabb_bvh.proto";
        if (!aabb_bvh.ExportBVHToProto(temp_aabb_path) || !IsFileValid(temp_aabb_path)) {
            all_success = false;
        }
        std::string temp_sphere_path = temp_cache_dir + "/sphere_bvh.proto";
        if (!sphere_bvh.ExportBVHToProto(temp_sphere_path) || !IsFileValid(temp_sphere_path)) {
            all_success = false;
        }

        // 2. 保存成功则替换旧缓存（先备份，失败恢复）
        if (all_success) {
            // 备份旧缓存（若存在）
            if (std::filesystem::exists(GetCacheDir(scene_id))) {
                std::filesystem::remove_all(backup_cache_dir); // 清空旧备份
                std::filesystem::rename(GetCacheDir(scene_id), backup_cache_dir);
            }
            // 替换为新缓存
            std::filesystem::remove_all(GetCacheDir(scene_id));
            std::filesystem::rename(temp_cache_dir, GetCacheDir(scene_id));
            // 删除备份（替换成功）
            std::filesystem::remove_all(backup_cache_dir);
            std::cout << "SceneCacheManager: 缓存保存完成 - " << scene_id << std::endl;
            return true;
        }
        else {
            std::filesystem::remove_all(temp_cache_dir);
            std::cerr << "SceneCacheManager: 保存失败，保留旧缓存" << std::endl;
            return false;
        }
    }
    catch (const std::exception& e) {
        std::filesystem::remove_all(temp_cache_dir);
        // 恢复备份（保存失败）
        if (std::filesystem::exists(backup_cache_dir)) {
            std::filesystem::remove_all(GetCacheDir(scene_id));
            std::filesystem::rename(backup_cache_dir, GetCacheDir(scene_id));
        }
        std::cerr << "SceneCacheManager: 保存缓存异常 - " << e.what() << " | 已恢复旧缓存" << std::endl;
        return false;
    }
}

// 删除指定场景的缓存（无修改）
bool SceneCacheManager::DeleteCache(const std::string& scene_id) const {
    try {
        std::string cache_dir = GetCacheDir(scene_id);
        if (std::filesystem::exists(cache_dir)) {
            std::filesystem::remove_all(cache_dir);
            std::cout << "SceneCacheManager: 已删除缓存 - " << scene_id << std::endl;
            return true;
        }
        return false;
    }
    catch (const std::exception& e) {
        std::cerr << "SceneCacheManager: 删除缓存失败 - " << e.what() << std::endl;
        return false;
    }
}

// 路径生成函数（【修改3】统一循环替换所有反斜杠）
std::string SceneCacheManager::GetCacheDir(const std::string& scene_id) const {
    std::filesystem::path cache_dir = cache_root_ / scene_id;
    std::string path_str = cache_dir.string();
    size_t pos = 0;
    while ((pos = path_str.find("\\", pos)) != std::string::npos) {
        path_str.replace(pos, 1, "/");
        pos += 1;
    }
    return path_str;
}

std::string SceneCacheManager::GetSceneDataCachePath(const std::string& scene_id) const {
    std::filesystem::path scene_data_path = cache_root_ / scene_id / "scene_data.proto";
    std::string path_str = scene_data_path.string();
    size_t pos = 0;
    while ((pos = path_str.find("\\", pos)) != std::string::npos) {
        path_str.replace(pos, 1, "/");
        pos += 1;
    }
    return path_str;
}

std::string SceneCacheManager::GetAABB_BVHCachedPath(const std::string& scene_id) const {
    std::filesystem::path path = cache_root_ / scene_id / "aabb_bvh.proto";
    std::string path_str = path.string();
    size_t pos = 0;
    while ((pos = path_str.find("\\", pos)) != std::string::npos) {
        path_str.replace(pos, 1, "/");
        pos += 1;
    }
    return path_str;
}

std::string SceneCacheManager::GetSphere_BVHCachedPath(const std::string& scene_id) const {
    std::filesystem::path path = cache_root_ / scene_id / "sphere_bvh.proto";
    std::string path_str = path.string();
    size_t pos = 0;
    while ((pos = path_str.find("\\", pos)) != std::string::npos) {
        path_str.replace(pos, 1, "/");
        pos += 1;
    }
    return path_str;
}

// 创建缓存目录（无修改）
bool SceneCacheManager::CreateCacheDir(const std::string& scene_id) const {
    try {
        std::filesystem::path cache_dir = cache_root_ / scene_id;
        if (!std::filesystem::exists(cache_dir)) {
            std::filesystem::create_directories(cache_dir);
            std::cout << "SceneCacheManager: 创建新场景缓存目录 - " << cache_dir << std::endl;
        }
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "SceneCacheManager: 创建缓存目录异常 - " << e.what() << std::endl;
        return false;
    }
}

// 校验单个缓存文件的完整性（无核心修改）
bool SceneCacheManager::ValidateCacheFile(const std::string& filepath) const {
    if (!IsFileValid(filepath)) {
        return false;
    }

    try {
        if (filepath.find("aabb_bvh.proto") != std::string::npos ||
            filepath.find("sphere_bvh.proto") != std::string::npos) {
            std::cout << "SceneCacheManager: 校验BVH文件 - " << filepath << std::endl;
            BVHProto::BVHStructureProto temp_bvh = ProtoUtils::DeserializeBVHStructure(filepath);
            if (temp_bvh.nodes_size() <= 0) {
                std::cerr << "SceneCacheManager: BVH文件无节点数据 - " << filepath << std::endl;
                return false;
            }
        }
        else if (filepath.find("scene_data.proto") != std::string::npos) {
            std::cout << "SceneCacheManager: 校验场景数据文件 - " << filepath << std::endl;
            BVHProto::SceneDataProto temp_scene = ProtoUtils::DeserializeSceneData(filepath);
            if (temp_scene.vertices_size() <= 0) {
                std::cerr << "SceneCacheManager: 场景数据文件无顶点数据 - " << filepath << std::endl;
                return false;
            }
        }
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "SceneCacheManager: 反序列化异常 - " << filepath << " | 错误: " << e.what() << std::endl;
        return false;
    }
}